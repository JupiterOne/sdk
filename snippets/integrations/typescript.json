{
  "Integration step": {
    "prefix": "j1-step",
    "body": [
      "export const ${1:user}Step: IntegrationStep<IntegrationConfig>[] = [",
      "  {",
      "    /**",
      "     * Points to a constant in src/step/constants.ts ",
      "     */",
      "    id: Steps.${1/(.*)/${1:/upcase}/}S,",
      "    /**",
      "     * Friendly name that will be displayed in debug logs",
      "     * and to customers in the job event log.",
      "     */",
      "    name: 'Fetch ${1/(.*)/${1:/capitalize}/}s',",
      "    /**",
      "     * Metadata about the entities ingested in this integration step. This is",
      "     * used to generate documentation.",
      "     * Points to a constant in src/steps/constants.ts",
      "     */",
      "    entities: [Entities.${1/(.*)/${1:/upcase}/}],",
      "    /**",
      "     * Metadata about the relationships ingested in this integration step. This is",
      "     * used to generate documentation.",
      "     */",
      "    relationships: [$2],",
      "    /**",
      "     * Metadata about any mapped relationships ingested in this integration step. This is",
      "     * used to generate documentation.",
      "     */",
      "    mappedRelationships: [$3],",
      "    /**",
      "     * An optional array of other step ids that need to execute",
      "     * before the current step can.",
      "     */",
      "    dependsOn: [$4],",
      "    /**",
      "     * Function that runs to perform the step",
      "     */",
      "    executionHandler: fetch${1/(.*)/${1:/capitalize}/}s, /* Use j1-exec-handler snippet to generate this function and call it here */",
      "  }",
      "];"
    ],
    "description": "Creates a new integration step"
  },
  "Static Execution Handler": {
    "prefix": "j1-execution-handler-static",
    "body": [
      "import { create${1/(.*)/${1:/capitalize}/}Entity } from './converter';",
      "",
      "export const ${1/(.*)/${1:/upcase}/}_ENTITY_KEY = 'entity:${1:account}';",
      "",
      "// TODO: Modify this comment with an explanation that reflects the purpose of this executionHandler",
      "/**",
      " * The executionHandler is where the work for the step happens. ",
      " * The executionHandler is a function that takes in the IntegrationStepExecutionContext",
      " * as a parameter and performs the necessary work to create entities and relationships.",
      " */",
      "export async function fetch${1/(.*)/${1:/capitalize}/}Details({",
      "  instance,",
      "  jobState,",
      "  logger,",
      "}: IntegrationStepExecutionContext<IntegrationConfig>) {",
      "  const ${1:account}Entity = await jobState.addEntity(create${1/(.*)/${1:/capitalize}/}Entity());",
      "",
      "  await jobState.setData(${1/(.*)/${1:/upcase}/}_ENTITY_KEY, ${1:account}Entity);",
      "}"
    ],
    "description": "Creates a static execution handler"
  },
  "Execution Handler": {
    "prefix": "j1-execution-handler",
    "body": [
      "import { createAPIClient } from '../../client';",
      "import { create${1/(.*)/${1:/capitalize}/}Entity, create${2/(.*)/${1:/capitalize}/}${1/(.*)/${1:/capitalize}/}Relationship } from './converter';",
      "",
      "// TODO: Modify this comment with an explanation that reflects the purpose of this executionHandler",
      "/**",
      " * The executionHandler is where the work for the step happens. ",
      " * The executionHandler is a function that takes in the IntegrationStepExecutionContext",
      " * as a parameter and performs the necessary work to create entities and relationships.",
      " */",
      "export async function fetch${1/(.*)/${1:/capitalize}/}s({",
      "  instance,",
      "  jobState,",
      "  logger,",
      "}: IntegrationStepExecutionContext<IntegrationConfig>) {",
      "  const apiClient = createAPIClient(instance.config, logger);",
      "",
      "  const ${2:account}Entity = (await jobState.getData(${2/(.*)/${1:/upcase}/}_ENTITY_KEY)) as Entity;",
      "",
      "  await apiClient.iterate${1/(.*)/${1:/capitalize}/}s(async (${1:user}) => {",
      "    const ${1:user}Entity = await jobState.addEntity(create${1/(.*)/${1:/capitalize}/}Entity(${1:user}));",
      "    // Add relationship between ${2:account} and ${1:user}",
      "    await jobState.addRelationship(",
      "      create${2/(.*)/${1:/capitalize}/}${1/(.*)/${1:/capitalize}/}Relationship(${2:account}Entity, ${1:user}Entity),",
      "    );",
      "  });",
      "}"
    ],
    "description": "Creates an execution handler that performs an API call to add multiple entities and/or relationships"
  },
  "Converter": {
    "prefix": "j1-converter",
    "body": [
      "import {",
      "  createIntegrationEntity,",
      "  Entity,",
      "} from '@jupiterone/integration-sdk-core';",
      "import { ${1/(.*)/${1:/capitalize}/}${2/(.*)/${1:/capitalize}/} } from '../../types';",
      "",
      "import { Entities } from '../constants';",
      "",
      "// TODO: Modify this comment with an explanation that reflects the purpose of this converter",
      "/**",
      " *  Different providers will present data in many different ways. ",
      " *  We want to normalize our data to be more consistent, so we can gather ",
      " *  useful insights from it. The converter will create the normalized entity ",
      " *  or relationship from the raw data the provider gives in an API response.",
      " * @param ${2:account}",
      " * @returns Normalized J1 ${1:Provider} ${2:account}",
      " */",
      "",
      "export function create${2/(.*)/${1:/capitalize}/}Entity(${2:account}: ${1/(.*)/${1:/capitalize}/}${2/(.*)/${1:/capitalize}/}): Entity {",
      "  return createIntegrationEntity({",
      "    entityData: {",
      "      source: ${2:account},",
      "      assign: {",
      "        _key: ${2:account}.uuid,",
      "        _type: Entities.${2/(.*)/${1:/upcase}/}._type,",
      "        _class: Entities.${2/(.*)/${1:/upcase}/}._class,",
      "        name: '${2/(.*)/${1:/capitalize}/}',",
      "        /** Add more fields */",
      "        email: ${2:account}.email,",
      "      },",
      "    },",
      "  });",
      "}"
    ],
    "description": "Creates a Converter"
  },
  "Step Spec": {
    "prefix": "j1-spec",
    "body": [
      "export const ${1:user}Spec: StepSpec<IntegrationConfig>[] = [",
      "  {",
      "    /**",
      "     * ENDPOINT: https://api.${2:provider}.com/api/v1/${1:user}s",
      "     * PATTERN: Fetch Entities",
      "     */",
      "    id: 'fetch-${1:user}s',",
      "    name: 'Fetch ${1/(.*)/${1:/capitalize}/}s',",
      "    entities: [",
      "      {",
      "        resourceName: '${1/(.*)/${1:/capitalize}/}',",
      "        _type: '${2:provider}_${1:user}',",
      "        _class: ['${1/(.*)/${1:/capitalize}/}']",
      "      }",
      "    ],",
      "    relationships: [],",
      "    mappedRelationships: [],",
      "    dependsOn: [],",
      "    implemented: true,",
      "  }",
      "];"
    ],
    "description": "Creates the spec of a new step."
  },
  "Entity Metadata": {
    "prefix": "j1-entity-metadata",
    "body": [
      "{",
      "  resourceName: '${1/(.*)/${1:/capitalize}/}',",
      "  _type: '${2:provider}_${1:user}',",
      "  _class: ['${1/(.*)/${1:/capitalize}/}']",
      "},"
    ],
    "description": "Add Entity Metadata Snippet"
  },
  "Relationship Metadata": {
    "prefix": "j1-relationship-metadata",
    "body": [
      "{",
      "  sourceType: '${4:provider}_${1:account}',",
      "  targetType: '${4:provider}_${2:user}',",
      "  _type: '${4:provider}_${1:account}_${3:has}_${2:user}',",
      "  _class: RelationshipClass.${3/(.*)/${1:/upcase}/},",
      "},"
    ],
    "description": "Relationship Metadata Snippet"
  },
  "GetStepStartStates": {
    "prefix": "j1-get-step-start-states",
    "body": [
      "export function getStepStartStates({",
      "  instance,",
      "  logger,",
      "}: IntegrationExecutionContext<IntegrationConfig>): StepStartStates {",
      "  $0",
      "}"
    ],
    "description": "GetStepStartStates Snippet"
  },
  "Pagination": {
    "prefix": "j1-pagination",
    "body": [
      "// TODO: Move the next code to the top of the client.ts file",
      "/*",
      "import fetch, { Response as NodeFetchResponse } from 'node-fetch';",
      "import { IntegrationError } from '@jupiterone/integration-sdk-core';",
      "import { URLSearchParams } from 'url';",
      "",
      "export type ResourceIteratee<T> = (each: T) => Promise<void> | void;",
      "export interface ProviderResponse<T> extends NodeFetchResponse {",
      "  json(): Promise<T>;",
      "}",
      "",
      "const ITEMS_PER_PAGE = 1000;",
      "*/",
      "",
      "/**",
      " * Iterates each ${1:user} resource in the provider.",
      " *",
      " * @param iteratee receives each resource to produce entities/relationships",
      " */",
      "public async iterate${1/(.*)/${1:/capitalize}/}s(iteratee: ResourceIteratee<${1/(.*)/${1:/capitalize}/}>): Promise<void> {",
      "  let currentPage = 1,",
      "    totalPages = 0;",
      "",
      "  do {",
      "    const response = await this.fetch${1/(.*)/${1:/capitalize}/}s(currentPage, ITEMS_PER_PAGE);",
      "    const result = await response.json();",
      "",
      "    // Get total pages via response",
      "    totalPages = result.paging.totalPages;",
      "    /* Get total pages via response header",
      "    totalPages = parseInt(",
      "      response.headers.get('X-Total-Pages') as string,",
      "      10,",
      "    );",
      "    */",
      "",
      "    if (Array.isArray(result.data)) {",
      "      for (const resource of result.data) {",
      "        await iteratee(resource);",
      "      }",
      "    } else {",
      "      throw new IntegrationError({",
      "        code: 'UNEXPECTED_RESPONSE_DATA',",
      "        message: `Expected a collection of resources but type was ${typeof result}`,",
      "      });",
      "    }",
      "",
      "    // Increase currentPage",
      "    currentPage++;",
      "  } while (currentPage <= totalPages);",
      "}",
      "",
      "private async fetch${1/(.*)/${1:/capitalize}/}s(page: number, pageSize: number) {",
      "  const searchParams = new URLSearchParams({",
      "    page: page.toString(),",
      "    pageSize: ITEMS_PER_PAGE.toString(),",
      "  });",
      "  const endpoint = `/api/v1/${1:user}s?${searchParams.toString()}`;",
      "",
      "  return this.request<ProviderResponse>(endpoint, 'get'); // use j1-request-with-retries to generate this method",
      "}"
    ],
    "description": "Iterates a resource in a provider by making a paginated request"
  },
  "Rate Limiting": {
    "prefix": "j1-rate-limit",
    "body": [
      "// TODO: move this to the top of the client.ts file",
      "/*",
      "import fetch, { Response as NodeFetchResponse } from 'node-fetch';",
      "import { sleep } from '@lifeomic/attempt'",
      "",
      "export interface RateLimitStatus {",
      "  limit: number;",
      "  remaining: number;",
      "  reset: number;",
      "}",
      "",
      "export interface ProviderResponse<T> extends NodeFetchResponse {",
      "  json(): Promise<T>;",
      "}",
      "*/",
      "",
      "// TODO: move this to the top of the class",
      "// private rateLimitStatus: RateLimitStatus;",
      "",
      "/**",
      " * Pulls rate limit headers from response.",
      " * @param response",
      " * @private",
      " */",
      "private setRateLimitStatus<T>(response: ProviderResponse<T>) {",
      "  // X-RateLimit-Limit: Request limit per hour",
      "  const limit = response.headers.get('X-RateLimit-Limit');",
      "  // X-RateLimit-Remaining: The number of requests left for the time window ",
      "  const remaining = response.headers.get('X-RateLimit-Remaining');",
      "  // X-RateLimit-Reset: The remaining window before the rate limit resets in UTC epoch seconds    ",
      "  const reset = response.headers.get('X-RateLimit-Reset');",
      "",
      "  if (limit && remaining && reset) {",
      "    this.rateLimitStatus = {",
      "      limit: Number(limit),",
      "      remaining: Number(remaining),",
      "      reset: Number(reset),",
      "    };",
      "  }",
      "",
      "  this.logger.info(this.rateLimitStatus, 'Rate limit status.');",
      "}",
      "",
      "/**",
      " * Determines if approaching the rate limit, sleeps until rate limit has reset.",
      " * Use this function whenever you want to check the rate limit of your API",
      " * Example: await this.checkRateLimitStatus();",
      " */",
      "private async checkRateLimitStatus() {",
      "  if (this.rateLimitStatus) {",
      "    const rateLimitRemainingProportion =",
      "      this.rateLimitStatus.remaining / this.rateLimitStatus.limit;",
      "    const msUntilRateLimitReset = this.rateLimitStatus.reset - Date.now();",
      "",
      "    if (rateLimitRemainingProportion <= 0.1 && msUntilRateLimitReset > 0) {",
      "      this.logger.info(",
      "        {",
      "          rateLimitStatus: this.rateLimitStatus,",
      "          msUntilRateLimitReset,",
      "          rateLimitRemainingProportion,",
      "        },",
      "        `Reached rate limits, sleeping now.`,",
      "      );",
      "      await sleep(msUntilRateLimitReset);",
      "    }",
      "  }",
      "}"
    ],
    "description": "Provides a set of methods to check the rate limit of an API"
  },
  "Request With Retries": {
    "prefix": "j1-request-with-retries",
    "body": [
      "// TODO: Move this to the top of the client.ts file",
      "/*",
      "import fetch, { RequestInit, Response as NodeFetchResponse } from 'node-fetch';",
      "import { retry } from '@lifeomic/attempt';",
      "import {",
      "  IntegrationProviderAPIError,",
      "  IntegrationProviderAuthenticationError,",
      "  IntegrationProviderAuthorizationError,",
      "} from '@jupiterone/integration-sdk-core';",
      "",
      "export interface ProviderResponse<T> extends NodeFetchResponse {",
      "  json(): Promise<T>;",
      "}",
      "",
      "export enum Method {",
      "  GET = 'get',",
      "  POST = 'post'",
      "}",
      "*/",
      "",
      "// TODO: move this to the top of the class",
      "/*",
      "private readonly BASE_URL = 'https://api.provider.com'",
      "private readonly headers: RequestInit['headers'];",
      "*/",
      "",
      "private async request<T>(",
      "  endpoint: string,",
      "  method: Method,",
      "  body?: {},",
      "): Promise<ProviderResponse<T>> {",
      "  const requestAttempt = async () => {",
      "    // Check rate limit status before each request",
      "    // await this.checkRateLimitStatus(); // Use j1-rate-limit snippet to generate this function",
      "    const requestOptions: RequestInit = {",
      "      method,",
      "      headers: this.headers,",
      "    };",
      "    if (body) {",
      "      requestOptions.body = JSON.stringify(body);",
      "    }",
      "",
      "    const response: ProviderResponse<T> = (await fetch(",
      "      this.BASE_URL + endpoint,",
      "      requestOptions,",
      "    )) as ProviderResponse<T>;",
      "",
      "    if (response.status === 401) {",
      "      throw new IntegrationProviderAuthenticationError({",
      "        endpoint,",
      "        status: response.status,",
      "        statusText: response.statusText,",
      "      });",
      "    } else if (response.status === 403) {",
      "      throw new IntegrationProviderAuthorizationError({",
      "        endpoint,",
      "        status: response.status,",
      "        statusText: response.statusText,",
      "      });",
      "    } else if (!response.ok) {",
      "      throw new IntegrationProviderAPIError({",
      "        endpoint,",
      "        status: response.status,",
      "        statusText: response.statusText,",
      "      });",
      "    } else if (response.status === 200) {",
      "      // Set a new rate limit status after each successful request",
      "      // this.setRateLimitStatus(response); // Use j1-rate-limit snippet to generate this function",
      "    }",
      "",
      "    return response;",
      "  };",
      "",
      "  return await retry(requestAttempt, {",
      "    // The maximum number of attempts or 0 if there is no limit on number of attempts.",
      "    maxAttempts: 3,",
      "    // The delay between each attempt in milliseconds. You can provide a factor to have the delay grow exponentially.",
      "    delay: 30_000,",
      "    // A timeout in milliseconds. If timeout is non-zero then a timer is set using setTimeout. ",
      "    // If the timeout is triggered then future attempts will be aborted.",
      "    timeout: 180_000,",
      "    // The factor option is used to grow the delay exponentially. ",
      "    // For example, a value of 2 will cause the delay to double each time ",
      "    factor: 2,",
      "    handleError: (error, attemptContext) => {",
      "      if ([401, 403, 404].includes(error.status)) {",
      "        attemptContext.abort();",
      "      }",
      "",
      "      if (attemptContext.aborted) {",
      "        this.logger.warn(",
      "          { attemptContext, error, endpoint },",
      "          'Hit an unrecoverable error from API Provider. Aborting.',",
      "        );",
      "      } else {",
      "        this.logger.warn(",
      "          { attemptContext, error, endpoint },",
      "          `Hit a possibly recoverable error from API Provider. Waiting before trying again.`,",
      "        );",
      "      }",
      "    },",
      "  });",
      "}"
    ],
    "description": "Adds a new method to perform API requests with retries and/or rate limit checks"
  }
}
